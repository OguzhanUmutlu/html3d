!function(){let t=new THREE.Vector3,e=new THREE.Line3,i=new THREE.Plane,n=new THREE.Vector3,s=new THREE.Triangle;class r{constructor(){this.normal=new THREE.Vector3,this.midpoint=new THREE.Vector3,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}static create(t,e,i){let n=new r,s=new l(t,n),o=new l(e,n),a=new l(i,n);return s.next=a.prev=o,o.next=s.prev=a,a.next=o.prev=s,n.edge=s,n.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){let t=this.edge.tail(),e=this.edge.head(),i=this.edge.next.head();return s.set(t.point,e.point,i.point),s.getNormal(this.normal),s.getMidpoint(this.midpoint),this.area=s.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class l{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){let t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){let t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class o{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class a{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}THREE.ConvexHull=class s{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new a,this.unassigned=new a,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.vertices.push(new o(t[e]));this.compute()}return this}setFromObject(t){let e=[];return t.updateMatrixWorld(!0),t.traverse(function(t){let i=t.geometry;if(void 0!==i){let n=i.attributes.position;if(void 0!==n)for(let s=0,r=n.count;s<r;s++){let l=new THREE.Vector3;l.fromBufferAttribute(n,s).applyMatrix4(t.matrixWorld),e.push(l)}}}),this.setFromPoints(e)}containsPoint(t){let e=this.faces;for(let i=0,n=e.length;i<n;i++){let s=e[i];if(s.distanceToPoint(t)>this.tolerance)return!1}return!0}intersectRay(t,e){let i=this.faces,n=-1/0,s=1/0;for(let r=0,l=i.length;r<l;r++){let o=i[r],a=o.distanceToPoint(t.origin),h=o.normal.dot(t.direction);if(a>0&&h>=0)return null;let u=0!==h?-a/h:0;if(!(u<=0)&&(h>0?s=Math.min(u,s):n=Math.max(u,n),n>s))return null}return n!==-1/0?t.at(n,e):t.at(s,e),e}intersectsRay(e){return null!==this.intersectRay(e,t)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){let e=t.outside,i=t.outside;for(;null!==i.next&&i.next.face===t;)i=i.next;return this.assigned.removeSubList(e,i),e.prev=i.next=null,t.outside=null,e}}deleteFaceVertices(t,e){let i=this.removeAllVerticesFromFace(t);if(void 0!==i){if(void 0===e)this.unassigned.appendChain(i);else{let n=i;do{let s=n.next,r=e.distanceToPoint(n.point);r>this.tolerance?this.addVertexToFace(n,e):this.unassigned.append(n),n=s}while(null!==n)}}return this}resolveUnassignedPoints(t){if(!1===this.unassigned.isEmpty()){let e=this.unassigned.first();do{let i=e.next,n=this.tolerance,s=null;for(let r=0;r<t.length;r++){let l=t[r];if(0===l.mark){let o=l.distanceToPoint(e.point);if(o>n&&(n=o,s=l),n>1e3*this.tolerance)break}}null!==s&&this.addVertexToFace(e,s),e=i}while(null!==e)}return this}computeExtremes(){let t=new THREE.Vector3,e=new THREE.Vector3,i=[],n=[];for(let s=0;s<3;s++)i[s]=n[s]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let r=0,l=this.vertices.length;r<l;r++){let o=this.vertices[r],a=o.point;for(let h=0;h<3;h++)a.getComponent(h)<t.getComponent(h)&&(t.setComponent(h,a.getComponent(h)),i[h]=o);for(let u=0;u<3;u++)a.getComponent(u)>e.getComponent(u)&&(e.setComponent(u,a.getComponent(u)),n[u]=o)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:i,max:n}}computeInitialHull(){let t=this.vertices,s=this.computeExtremes(),l=s.min,o=s.max,a=0,h=0;for(let u=0;u<3;u++){let c=o[u].point.getComponent(u)-l[u].point.getComponent(u);c>a&&(a=c,h=u)}let d=l[h],p=o[h],g,f;a=0,e.set(d.point,p.point);for(let x=0,m=this.vertices.length;x<m;x++){let $=t[x];if($!==d&&$!==p){e.closestPointToPoint($.point,!0,n);let v=n.distanceToSquared($.point);v>a&&(a=v,g=$)}}a=-1,i.setFromCoplanarPoints(d.point,p.point,g.point);for(let w=0,T=this.vertices.length;w<T;w++){let F=t[w];if(F!==d&&F!==p&&F!==g){let _=Math.abs(i.distanceToPoint(F.point));_>a&&(a=_,f=F)}}let V=[];if(0>i.distanceToPoint(f.point)){V.push(r.create(d,p,g),r.create(f,p,d),r.create(f,g,p),r.create(f,d,g));for(let E=0;E<3;E++){let P=(E+1)%3;V[E+1].getEdge(2).setTwin(V[0].getEdge(P)),V[E+1].getEdge(1).setTwin(V[P+1].getEdge(0))}}else{V.push(r.create(d,g,p),r.create(f,d,p),r.create(f,p,g),r.create(f,g,d));for(let y=0;y<3;y++){let C=(y+1)%3;V[y+1].getEdge(2).setTwin(V[0].getEdge((3-y)%3)),V[y+1].getEdge(0).setTwin(V[C+1].getEdge(1))}}for(let b=0;b<4;b++)this.faces.push(V[b]);for(let A=0,k=t.length;A<k;A++){let H=t[A];if(H!==d&&H!==p&&H!==g&&H!==f){a=this.tolerance;let S=null;for(let z=0;z<4;z++){let L=this.faces[z].distanceToPoint(H.point);L>a&&(a=L,S=this.faces[z])}null!==S&&this.addVertexToFace(H,S)}}return this}reindexFaces(){let t=[];for(let e=0;e<this.faces.length;e++){let i=this.faces[e];0===i.mark&&t.push(i)}return this.faces=t,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0,i=this.assigned.first().face,n=i.outside;do{let s=i.distanceToPoint(n.point);s>e&&(e=s,t=n),n=n.next}while(null!==n&&n.face===i);return t}}computeHorizon(t,e,i,n){this.deleteFaceVertices(i),i.mark=1;let s;s=null===e?e=i.getEdge(0):e.next;do{let r=s.twin,l=r.face;0===l.mark&&(l.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,r,l,n):n.push(s)),s=s.next}while(s!==e);return this}addAdjoiningFace(t,e){let i=r.create(t,e.tail(),e.head());return this.faces.push(i),i.getEdge(-1).setTwin(e.twin),i.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let i=null,n=null;for(let s=0;s<e.length;s++){let r=e[s],l=this.addAdjoiningFace(t,r);null===i?i=l:l.next.setTwin(n),this.newFaces.push(l.face),n=l}return i.next.setTwin(n),this}addVertexToHull(t){let e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();void 0!==(t=this.nextVertexToAdd());)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}}();